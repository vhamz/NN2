<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neural Network Design: The Gradient Puzzle</title>
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <style>
      :root {
        --bg-color: #1e1e2e;
        --card-bg: #2b2b3b;
        --text-main: #e0e0e0;
        --accent: #4a90e2;
        --success: #50c878;
        --warning: #ffcc00;
        --danger: #ff5555;
        --border-radius: 8px;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-main);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      h1 {
        margin-bottom: 20px;
        text-align: center;
        font-weight: 300;
      }

      /* Control Panel */
      .controls {
        background-color: var(--card-bg);
        padding: 15px 25px;
        border-radius: var(--border-radius);
        margin-bottom: 25px;
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }
      .control-group {
        display: flex;
        gap: 10px;
        align-items: center;
        border-right: 1px solid #444;
        padding-right: 20px;
      }
      .control-group:last-child {
        border-right: none;
        padding-right: 0;
      }

      button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: opacity 0.2s;
      }
      button:hover {
        opacity: 0.9;
      }
      .btn-train {
        background-color: var(--accent);
        color: white;
      }
      .btn-auto {
        background-color: var(--success);
        color: white;
      }
      .btn-reset {
        background-color: var(--danger);
        color: white;
      }
      .btn-stop {
        background-color: var(--warning);
        color: #333;
      }

      label {
        margin-right: 8px;
        cursor: pointer;
      }

      /* Visualization Grid */
      .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 30px;
        width: 100%;
        max-width: 1000px;
      }
      .card {
        background-color: var(--card-bg);
        padding: 20px;
        border-radius: var(--border-radius);
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }
      .card h3 {
        margin-top: 0;
        color: var(--accent);
        font-size: 1.1em;
      }
      .card p {
        font-size: 0.9em;
        color: #aaa;
        margin-bottom: 10px;
      }

      canvas {
        border: 2px solid #555;
        image-rendering: pixelated; /* Sharp pixels */
        width: 256px;
        height: 256px;
        background-color: black;
        margin-bottom: 10px;
      }
      .loss-display {
        font-family: monospace;
        font-size: 0.9em;
        color: var(--success);
      }

      /* Logs */
      #log-area {
        width: 100%;
        max-width: 1000px;
        margin-top: 20px;
        padding: 15px;
        background-color: #111;
        color: #0f0;
        font-family: monospace;
        border-radius: 4px;
        height: 100px;
        overflow-y: auto;
        border: 1px solid #333;
      }
      .error {
        color: var(--danger);
      }

      /* Architecture Selection Highlight */
      .arch-selector input[type="radio"]:checked + span {
        color: var(--accent);
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>Neural Network Design: The Gradient Puzzle</h1>

    <div class="controls">
      <div class="control-group">
        <button id="btn-train" class="btn-train">Train 1 Step</button>
        <button id="btn-auto" class="btn-auto">Auto Train (Start)</button>
        <button id="btn-reset" class="btn-reset">Reset Weights</button>
      </div>

      <div class="control-group arch-selector">
        <strong>Architecture:</strong>
        <label
          ><input type="radio" name="arch" value="compression" />
          <span>Compression</span></label
        >
        <label
          ><input type="radio" name="arch" value="transformation" checked />
          <span>Transformation</span></label
        >
        <label
          ><input type="radio" name="arch" value="expansion" />
          <span>Expansion</span></label
        >
      </div>
    </div>

    <div class="grid-container">
      <!-- Card 1: Input -->
      <div class="card">
        <h3>Input (Noise)</h3>
        <p>Fixed Random Noise<br />[16x16]</p>
        <canvas id="canvas-input" width="16" height="16"></canvas>
        <div class="loss-display">-</div>
      </div>

      <!-- Card 2: Baseline -->
      <div class="card">
        <h3>Baseline Output</h3>
        <p>Model: Fixed Compression<br />Loss: MSE Only</p>
        <canvas id="canvas-baseline" width="16" height="16"></canvas>
        <div id="loss-baseline" class="loss-display">Loss: 0.0000</div>
      </div>

      <!-- Card 3: Student -->
      <div class="card" style="border: 2px solid var(--accent)">
        <h3>Student Output</h3>
        <p>
          Model: <span id="student-arch-label">Transformation</span><br />Loss:
          <strong>Custom</strong>
        </p>
        <canvas id="canvas-student" width="16" height="16"></canvas>
        <div id="loss-student" class="loss-display">Loss: 0.0000</div>
      </div>
    </div>

    <div id="log-area">
      Ready. Select architecture or edit app.js to customize logic...
    </div>

    <script>

/**
 * Neural Network Design: The Gradient Puzzle
 *
 * Objective:
 * Modify the Student Model architecture and loss function to transform
 * random noise input into a smooth, directional gradient output.
 */

// ==========================================
// 1. Global State & Config
// ==========================================
const CONFIG = {
  // Model definition shape (no batch dim) - used for layer creation
  inputShapeModel: [16, 16, 1],
  // Data tensor shape (includes batch dim) - used for input tensor creation
  inputShapeData: [1, 16, 16, 1],
  learningRate: 0.05,
  autoTrainSpeed: 50, // ms delay between steps (lower is faster)
};

let state = {
  step: 0,
  isAutoTraining: false,
  autoTrainInterval: null,
  xInput: null, // The fixed noise input
  baselineModel: null,
  studentModel: null,
  baselineOptimizer: null,
  studentOptimizer: null,
};

// ==========================================
// 2. Helper Functions (Loss Components)
// ==========================================

// Standard MSE: Mean Squared Error
function mse(yTrue, yPred) {
  return tf.losses.meanSquaredError(yTrue, yPred);
}

// TODO: Helper - Smoothness (Total Variation)
// Penalize differences between adjacent pixels to encourage smoothness.
function smoothness(yPred) {
  // Difference in X direction: pixel[i, j] - pixel[i, j+1]
  const diffX = yPred
    .slice([0, 0, 0, 0], [-1, -1, 15, -1])
    .sub(yPred.slice([0, 0, 1, 0], [-1, -1, 15, -1]));

  // Difference in Y direction: pixel[i, j] - pixel[i+1, j]
  const diffY = yPred
    .slice([0, 0, 0, 0], [-1, 15, -1, -1])
    .sub(yPred.slice([0, 1, 0, 0], [-1, 15, -1, -1]));

  // Return sum of squares
  return tf.mean(tf.square(diffX)).add(tf.mean(tf.square(diffY)));
}

// TODO: Helper - Directionality (Gradient)
// Encourage pixels on the right to be brighter than pixels on the left.
function directionX(yPred) {
  // Create a weight mask that increases from left (-1) to right (+1)
  // For 16x16, we can just use linspace
  const width = 16;
  const mask = tf.linspace(-1, 1, width).reshape([1, 1, width, 1]); // [1, 1, 16, 1]

  // We want yPred to correlate with mask.
  // Maximize (yPred * mask) => Minimize -(yPred * mask)
  return tf.mean(yPred.mul(mask)).mul(-1);
}

// ==========================================
// 3. Model Architecture
// ==========================================

// Baseline Model: Fixed Compression (Undercomplete AE)
// 16x16 -> 64 -> 16x16
function createBaselineModel() {
  const model = tf.sequential();
  model.add(tf.layers.flatten({ inputShape: CONFIG.inputShapeModel }));
  model.add(tf.layers.dense({ units: 64, activation: "relu" })); // Bottleneck
  model.add(tf.layers.dense({ units: 256, activation: "sigmoid" })); // Output 0-1
  // Reshape back to [16, 16, 1] (batch dim is handled automatically)
  model.add(tf.layers.reshape({ targetShape: [16, 16, 1] }));
  return model;
}

// ------------------------------------------------------------------
// [TODO-A]: STUDENT ARCHITECTURE DESIGN
// Modify this function to implement 'transformation' and 'expansion'.
// ------------------------------------------------------------------
function createStudentModel(archType) {
  const model = tf.sequential();
  model.add(tf.layers.flatten({ inputShape: CONFIG.inputShapeModel }));

  if (archType === "compression") {
    // [Implemented] Bottleneck: Compress information
    model.add(tf.layers.dense({ units: 64, activation: "relu" }));
    model.add(tf.layers.dense({ units: 256, activation: "sigmoid" }));
  } else if (archType === "transformation") {
    // Transformation (1:1 mapping): hidden = input size
    model.add(tf.layers.dense({units: 256, activation: 'relu'}));
    model.add(tf.layers.dense({units: 256, activation: 'sigmoid'}));
  } else if (archType === "expansion") {
    // Expansion (Overcomplete): hidden > input size
    model.add(tf.layers.dense({units: 512, activation: 'relu'}));
    model.add(tf.layers.dense({units: 256, activation: 'sigmoid'}));
  } else {
    // Safety check for unknown architectures
    throw new Error(`Unknown architecture type: ${archType}`);
  }

  model.add(tf.layers.reshape({ targetShape: [16, 16, 1] }));
  return model;
}

// ==========================================
// 4. Custom Loss Function
// ==========================================

// ------------------------------------------------------------------
// [TODO-B]: STUDENT LOSS DESIGN
// Modify this function to create a smooth gradient.
// Currently, it only uses MSE (Identity mapping).
// ------------------------------------------------------------------
function studentLoss(yTrue, yPred) {
  return tf.tidy(() => {
    const lossMSE = mse(yTrue, yPred);
    const lossSmooth = smoothness(yPred).mul(1.0);
    const lossDir = directionX(yPred).mul(0.1);
    return lossMSE.add(lossSmooth).add(lossDir);
  });
}

// ==========================================
// 5. Training Loop
// ==========================================

async function trainStep() {
  state.step++;

  // Safety check: Ensure models are initialized
  if (!state.studentModel || !state.studentModel.getWeights) {
    log("Error: Student model not initialized properly.", true);
    stopAutoTrain();
    return;
  }

  // Train Baseline (MSE Only)
  // We use a simple fit here or gradient tape, let's use tape for consistency
  const baselineLossVal = tf.tidy(() => {
    const { value, grads } = tf.variableGrads(() => {
      const yPred = state.baselineModel.predict(state.xInput);
      return mse(state.xInput, yPred); // Baseline always uses MSE
    }, state.baselineModel.getWeights());

    state.baselineOptimizer.applyGradients(grads);
    return value.dataSync()[0];
  });

  // Train Student (Custom Loss)
  let studentLossVal = 0;
  try {
    studentLossVal = tf.tidy(() => {
      const { value, grads } = tf.variableGrads(() => {
        const yPred = state.studentModel.predict(state.xInput);
        return studentLoss(state.xInput, yPred);
      }, state.studentModel.getWeights());

      state.studentOptimizer.applyGradients(grads);
      return value.dataSync()[0];
    });
    log(
      `Step ${state.step}: Base Loss=${baselineLossVal.toFixed(4)} | Student Loss=${studentLossVal.toFixed(4)}`,
    );
  } catch (e) {
    log(`Error in Student Training: ${e.message}`, true);
    stopAutoTrain();
    return;
  }

  // Visualize
  if (state.step % 5 === 0 || !state.isAutoTraining) {
    await render();
    updateLossDisplay(baselineLossVal, studentLossVal);
  }
}

// ==========================================
// 6. UI & Initialization logic
// ==========================================

function init() {
  // 1. Generate fixed noise (Batch size included: [1, 16, 16, 1])
  state.xInput = tf.randomUniform(CONFIG.inputShapeData);

  // 2. Initialize Models
  resetModels();

  // 3. Render Initial Input
  tf.browser.toPixels(
    state.xInput.squeeze(),
    document.getElementById("canvas-input"),
  );

  // 4. Bind Events
  document
    .getElementById("btn-train")
    .addEventListener("click", () => trainStep());
  document
    .getElementById("btn-auto")
    .addEventListener("click", toggleAutoTrain);
  document.getElementById("btn-reset").addEventListener("click", resetModels);

  document.querySelectorAll('input[name="arch"]').forEach((radio) => {
    radio.addEventListener("change", (e) => {
      resetModels(e.target.value);
      document.getElementById("student-arch-label").innerText =
        e.target.value.charAt(0).toUpperCase() + e.target.value.slice(1);
    });
  });

  log("Initialized. Ready to train.");
}

function resetModels(archType = null) {
  // [Fix]: When called via event listener, archType is an Event object.
  // We must ensure it's either a string or null.
  if (typeof archType !== "string") {
    archType = null;
  }

  // Safety: Stop auto-training to prevent race conditions during reset
  if (state.isAutoTraining) {
    stopAutoTrain();
  }

  if (!archType) {
    const checked = document.querySelector('input[name="arch"]:checked');
    archType = checked ? checked.value : "transformation";
  }

  // Dispose old resources to avoid memory leaks
  if (state.baselineModel) {
    state.baselineModel.dispose();
    state.baselineModel = null;
  }
  if (state.studentModel) {
    state.studentModel.dispose();
    state.studentModel = null;
  }
  if (state.baselineOptimizer) {
    state.baselineOptimizer.dispose();
    state.baselineOptimizer = null;
  }
  if (state.studentOptimizer) {
    state.studentOptimizer.dispose();
    state.studentOptimizer = null;
  }

  // Create New Models
  state.baselineModel = createBaselineModel();
  try {
    state.studentModel = createStudentModel(archType);
  } catch (e) {
    log(`Error creating model: ${e.message}`, true);
    state.studentModel = createBaselineModel(); // Fallback to avoid crash
  }

  state.baselineOptimizer = tf.train.adam(CONFIG.learningRate);
  state.studentOptimizer = tf.train.adam(CONFIG.learningRate);
  state.step = 0;

  log(`Models reset. Student Arch: ${archType}`);
  render();
}

async function render() {
  // Tensor memory management with tidy not possible here due to async toPixels,
  // so we manually dispose predictions.
  const basePred = state.baselineModel.predict(state.xInput);
  const studPred = state.studentModel.predict(state.xInput);

  await tf.browser.toPixels(
    basePred.squeeze(),
    document.getElementById("canvas-baseline"),
  );
  await tf.browser.toPixels(
    studPred.squeeze(),
    document.getElementById("canvas-student"),
  );

  basePred.dispose();
  studPred.dispose();
}

// UI Helpers
function updateLossDisplay(base, stud) {
  document.getElementById("loss-baseline").innerText =
    `Loss: ${base.toFixed(5)}`;
  document.getElementById("loss-student").innerText =
    `Loss: ${stud.toFixed(5)}`;
}

function log(msg, isError = false) {
  const el = document.getElementById("log-area");
  const span = document.createElement("div");
  span.innerText = `> ${msg}`;
  if (isError) span.classList.add("error");
  el.prepend(span);
}

// Auto Train Logic
function toggleAutoTrain() {
  const btn = document.getElementById("btn-auto");
  if (state.isAutoTraining) {
    stopAutoTrain();
  } else {
    state.isAutoTraining = true;
    btn.innerText = "Auto Train (Stop)";
    btn.classList.add("btn-stop");
    btn.classList.remove("btn-auto");
    loop();
  }
}

function stopAutoTrain() {
  state.isAutoTraining = false;
  const btn = document.getElementById("btn-auto");
  btn.innerText = "Auto Train (Start)";
  btn.classList.add("btn-auto");
  btn.classList.remove("btn-stop");
}

function loop() {
  if (state.isAutoTraining) {
    trainStep();
    setTimeout(loop, CONFIG.autoTrainSpeed);
  }
}

// Start
init();

</script>
  </body>
</html>
